<html>
  
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../../../../style.css">
    <base target="_parent">
    <title data-trilium-title>C和C++实战及经典考点</title>
  </head>
  
  <body>
    <div class="content">
       <h1 data-trilium-h1>C和C++实战及经典考点</h1>

      <div class="ck-content">
        <ul>
          <li><a href="#1.C++%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%A7%E7%AB%AF%E3%80%81%E5%B0%8F%E7%AB%AF%EF%BC%9F">1.C++中什么是大端、小端？</a>
          </li>
          <li><a href="#2.%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%A6%E8%83%BD%E5%A4%9F%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%E6%9D%A5%E5%8C%BA%E5%88%86%EF%BC%9F">2.重载函数是否能够通过函数返回值的类型不同来区分？</a>
          </li>
          <li><a href="#3.%E5%9C%A8C++%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%B0%83%E7%94%A8%E8%A2%ABC%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0extern%E2%80%9CC%E2%80%9D%EF%BC%9F">3.在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”</a>
          </li>
          <li><a href="#4.%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%EF%BC%9F">4.进程间如何通信？</a>
          </li>
          <li><a href="#5.%E5%9C%A8%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%AD%E6%B6%89%E5%8F%8A%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">5.在网络编程中涉及并发服务器，使用多进程与多线程的区别？</a>
          </li>
          <li><a href="#6.map%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">6. map的底层原理是什么？</a>
          </li>
          <li><a href="#7.socket%E4%B8%8E%E5%85%B6%E4%BB%96%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F">7. socket与其他通信方式有什么不同？</a>
          </li>
          <li><a href="#8.TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8CTCP%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E9%87%8D%E4%BC%A0%EF%BC%9F">8.TCP和UDP的区别是什么，TCP什么时候会重传？</a>
          </li>
          <li><a href="#9.map%E5%92%8Cunordered_map%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F">9. map和unordered_map了解吗？</a>
          </li>
          <li><a href="#10.hashmap%E5%92%8Cmap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">10.hashmap和map的区别，底层数据结构算法是什么？</a>
          </li>
          <li><a href="#11.%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F">11.介绍一下红黑树？</a>
          </li>
          <li><a href="#12.%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bhash">12.介绍一下hash</a>
          </li>
          <li><a href="#13.%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9F">13.介绍一下二叉树？</a>
          </li>
          <li><a href="#14.%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0LRU">14.编程实现LRU</a>
          </li>
          <li><a href="#15.%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0memcopy">15.编程实现memcopy</a>
          </li>
        </ul>
        
<h2>1.C++中什么是大端、小端？</h2>

        <p>大端（Big-endian）和小端（Little-endian）是指计算机中存储多字节数据时字节的排列顺序：大端将高字节存储在低地址处，低字节存储在高地址处；小端则将低字节存储在低地址处，高字节存储在高地址处。</p>
        
<h2>2.重载函数是否能够通过函数返回值的类型不同来区分？</h2>
不能。重载函数不能仅仅通过函数返回值类型的不同来区分。C++的函数重载是基于参数列表的不同（包括参数的数量、类型或顺序）来实现的，编译器无法仅根据返回类型来确定。
        
<h2>3.在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”？</h2>
首先，`extern` 是C/C++语言中用于指定函数和全局变量作用范围的关键字。它告诉编译器，这些声明的函数和变量可以在当前模块或其它模块中使用。
        <p>通常在模块的头文件中，对本模块提供给其它模块引用的函数和全局变量使用<code>extern</code>关键字进行声明。<code>extern "C"</code> 是一种连接声明(linkage
          declaration)，被 <code>extern "C"</code> 修饰的变量和函数按照C语言的方式进行编译和连接。作为面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为：<code>void foo(int x, int y);</code> 该函数被C编译器编译后在符号库中的名字为 <code>_foo</code>，而C++编译器则会产生像 <code>_foo_int_int</code> 之类的名字。这样的名字包含了函数名、函数参数数量及类型信息，C++通过这种机制实现函数重载。</p>
        <p>总结来说，<code>extern "C"</code> 声明的主要目的是解决名字匹配问题，从而实现C++与C的混合编程。</p>
        
<h2>4.进程间如何通信？</h2>
管道：允许一个进程和另一个与它有共同祖先的进程之间进行通信。 消息队列：消息的链表，存储在内核中，由进程间发送接收消息。 共享内存：允许多个进程访问同一块内存空间，是最快的IPC方式。
        信号量：主要用于解决进程间的同步问题。 套接字：适用于不同机器间的进程通信。 信号：用于通知接收进程某个事件已经发生。
        
<h2>5.在网络编程中涉及并发服务器，使用多进程与多线程的区别？</h2>
（1）线程执行开销小，但不利于资源管理和保护；进程则相反，进程可跨越机器迁移。 （2）多进程时每个进程都有自己的内存空间，而多线程间共享内存空间；
        （3）线程产生的速度快，线程间通信快、切换快； （4）线程的资源利用率比较好； （5）线程使用公共变量或者资源时需要同步机制。
        
<h2>6.map的底层原理是什么？</h2>

        <p>map的底层原理: map的底层是基于红黑树实现的。 红黑树是一种自平衡二叉搜索树，它能保证基本操作（如查找、插入、删除）的时间复杂度为O(log
          n)，确保树的高度保持在对数级别。 通过键值对自动排序和高效操作维持了其数据结构的稳定性和效率。</p>
        
<h2>7.socket与其他通信方式有什么不同？</h2>

        <p>Socket 可以实现不同主机间的进程通信，适用于网络中跨操作系统通信。 Socket 通常支持全双工通信，即同一时间可以进行数据的双向传输。
          Socket 支持面向连接（如TCP协议）和无连接（如UDP协议）的通信方式。 使用 Socket 进行通信需要创建、配置、使用和关闭套接字，比其他通信方式如管道和信号等有更明确的使用流程。</p>
        
<h2>8.TCP和UDP的区别是什么，TCP什么时候会重传？</h2>

        <p>连接： TCP是面向连接的协议，进行数据传输前需要建立连接。 UDP是无连接的协议，不需要建立连接就可以直接发送数据。 可靠性： TCP提供可靠的数据传输，确保数据完整性和顺序。
          UDP提供不可靠的数据传输，可能出现丢包，不保证数据顺序。 速度： TCP相对较慢，因为它需要确认机制和错误校正。 UDP传输速度更快，没有确认机制，适用于对速度要求高的场合。
          数据流： TCP提供字节流服务，通过数据流的方式发送数据。 UDP以数据报文的形式发送信息，发送独立的消息。</p>
        <p>超时重传：如果发送方在设定的超时时间内没有收到接收方的确认（ACK），它会重传那个数据段。 快速重传：如果发送方收到三个或更多的冗余ACK（即对同一个数据段的连续确认），它会在没有等待超时的情况下立即重传那个被认为丢失的数据段。
          接收方提示：接收方可以通过ACK中的SACK选项（选择确认），明确指出哪些数据段已收到，哪些未收到，促使发送方仅重传未被确认接收的数据段。</p>
        
<h2>9.map和unordered_map了解吗？</h2>
map： 底层实现是红黑树，一个自平衡的二叉搜索树。 元素根据键值自动排序。 插入、删除和查找操作的时间复杂度为O(log n)。
        <p>unordered_map： 底层实现是哈希表。 元素不会自动排序。 平均情况下插入、删除和查找操作的时间复杂度为O(1)，最坏情况下为O(n)。</p>
        
<h2>10.hashmap和map的区别，底层数据结构算法是什么？</h2>

        <p>在 C++ 中，虽然没有直接对应 HashMap 和 Map 的标准库接口，但可通过 unordered_map 和 map 实现类似功能。二者区别在于：
          底层实现不同：unordered_map 是哈希表实现，map 是红黑树实现。 元素顺序不同：unordered_map 不保证元素顺序，map
          按照键的自然顺序排序。 对空值的处理不同：从 C++11 开始，unordered_map 允许键和值为 null，map 不允许键为空。 底层数据结构算法方面：
          unordered_map 利用散列函数将键映射到存储桶，采用链地址法解决哈希冲突。 map 以红黑树为底层数据结构，保证元素有序，插入、删除和查找操作的时间复杂度为
          O (log N)。</p>
        
<h2>11.介绍一下红黑树</h2>

        <p>红黑树是一种自平衡二叉搜索树，在插入和删除操作后会通过调整节点颜色与进行旋转来维持平衡。其特点如下：</p>
        <ul>
          <li>节点颜色为红或黑。</li>
          <li>根节点为黑色。</li>
          <li>叶子节点（NULL 节点）皆为黑色。</li>
          <li>红色节点的两个子节点必为黑色，不可出现连续红色节点。</li>
          <li>从任一节点到其后代叶子节点的简单路径上，黑色节点数量一致，空子树到后代叶子节点的简单路径也如此。</li>
        </ul>
        <p>凭借这些规则，红黑树可保持良好的平衡性质，在最坏情况下能实现 O(logN)时间复杂度的搜索、插入和删除操作。</p>
        <p>对于插入操作，先将新节点设为红色，若违反红黑树性质 4 则进行旋转和变换修正，最后把根节点设为黑色。删除操作时，若被删除节点有两个非空子节点，需找到其后继节点（右子树最小值或左子树最大值），用后继节点替换原节点后再删除后继节点；若被删除节点只有一个子节点或无子节点则直接删除。删除后若违反性质
          4，同样要进行一系列旋转和变换来修正。</p>
        
<h2>12.介绍一下hash</h2>

        <p>哈希（Hash）是将任意长度的输入数据通过哈希函数</p>
        <p>（Hash Function）转换为固定长度的输出值的过程。哈希函数将输入数据映射到一个固定大小的哈希值，通常表示为一串数字或字母。</p>
        <p>哈希函数具有以下特点：</p>
<pre><code>输入相同的数据始终会得到相同的哈希值。
不同的输入数据产生不同的哈希值。
哈希值长度固定，无论输入数据多长，输出结果都是相同长度。
</code></pre>

        <p>在计算机领域，哈希常被用于以下方面：</p>
<pre><code>数据存储和索引：使用哈希表作为底层数据结构，通过键-值对存储和快速查找
</code></pre>

        <p>数据。 密码学：密码验证、数字签名</p>
<pre><code>、消息摘要等应用需要使用安全的哈希函数。
数据完整性校验：通过比较两个文件或消息的哈希值来判断是否一致。
数据唯一性标识：例如在分布式系统中使用一致性哈希来确定节点位置。
</code></pre>

        <p>常见的哈希函数包括MD5、SHA-1、SHA-256等，它们能够快速生成具有较低冲突率（即不同输入得到相同输出的概率很小）的哈希值。然而，在安全敏感场景下，通常需要使用更强大的哈希函数来抵抗攻击，如SHA-3或Blake2。</p>
        
<h2>13.介绍一下二叉树</h2>

        <p>二叉树（Binary Tree）是一种常见的树形数据结构，它由节点（Node）组成，每个节点最多有两个子节点：左子节点和右子节点。</p>
        <p>二叉树的特点如下：</p>
<pre><code>每个节点最多有两个子节点，分别称为左子节点和右子节点。
左子树和右子树也是二叉树，可以为空。
二叉树没有环路（即不存在从某个节点出发经过若干条边回到该节点的路径）。
</code></pre>

        <p>在二叉树中，通常会定义以下几种特殊类型的二叉树：</p>
<pre><code>完全二叉树
</code></pre>

        <p>（Complete Binary Tree）：除了最后一层外，其他层的所有节点都必须是满的，并且最后一层的所有节点都尽量靠左排列。 满二叉树</p>
<pre><code>（Full Binary Tree）：除了叶子节点外，每个内部节点都有两个子节点。
二叉搜索树（Binary Search Tree）：对于任意一个节点，其左子树上的值都小于等于该节点的值，右子树上的值都大于等于该节点的值。这种性质使得查找、插入和删除操作非常高效。
</code></pre>

        <p>二叉树可以用递归或迭代方式进行遍历，常见的遍历方式包括：</p>
<pre><code>前序遍历（Preorder Traversal）：先访问根节点，然后按照前序遍历顺序递归地遍历左子树和右子树。
中序遍历（Inorder Traversal）：先按照中序遍历顺序递归地遍历左子树，然后访问根节点，最后再递归地遍历右子树。
后序遍历（Postorder Traversal）：先按照后序遍历顺序递归地遍历左子树和右子树，最后访问根节点。
</code></pre>

        <p>二叉树在计算机科学中有广泛应用，例如表示算术表达式、数据库索引结构、图形渲染等。</p>
        
<h2>14.编程实现LRU</h2>
LRU（Least Recently Used，最近最少使用）是一种常用的缓存淘汰策略。
        <p>下面是一个手撕LRU缓存的示例实现：</p>
        <p>#include #include #include</p>
        <p>using namespace std;</p>
        <p>class LRUCache { private: int capacity; unordered_map&lt;int, pair&lt;int,
          list::iterator&gt;&gt; cache; // 存储键值对和对应迭代器 list lruList; // 存储访问顺序</p>
        <p>public: LRUCache(int cap) { capacity = cap; }</p>
<pre><code>int get(int key) {
    if (cache.find(key) == cache.end()) {  // 若key不存在于缓存中
        return -1;
    }

    // 将该元素移到链表头部表示最新访问
    lruList.erase(cache[key].second);
    lruList.push_front(key);
    cache[key].second = lruList.begin();

    return cache[key].first;  // 返回对应value值
}

void put(int key, int value) {
    if (cache.find(key) != cache.end()) {  // 若key已存在于缓存中，则更新value，并将其移到链表头部表示最新访问
        lruList.erase(cache[key].second);
        lruList.push_front(key);
        cache[key] = make_pair(value, lruList.begin());
        return;
    }

    if (cache.size() == capacity) {  // 缓存已满，需要淘汰末尾的元素（即最久未使用）
        int lastKey = lruList.back();
        cache.erase(lastKey);
        lruList.pop_back();
    }

    // 插入新元素到链表头部表示最新访问
    lruList.push_front(key);
    cache[key] = make_pair(value, lruList.begin());
}
</code></pre>

        <p>};</p>
        <p>int main() { LRUCache cache(2); // 创建容量为2的LRU缓存</p>
<pre><code>cache.put(1, 1);
cache.put(2, 2);
cout &lt;&lt; cache.get(1) &lt;&lt; endl;  // 输出：1
cache.put(3, 3); 
cout &lt;&lt; cache.get(2) &lt;&lt; endl;  // 输出：-1，因为key=2被淘汰了
cache.put(4, 4);
cout &lt;&lt; cache.get(1) &lt;&lt; endl;  // 输出：-1，因为key=1被淘汰了
cout &lt;&lt; cache.get(3) &lt;&lt; endl;  // 输出：3
cout &lt;&lt; cache.get(4) &lt;&lt; endl;  // 输出：4

return 0;
</code></pre>

        <p>}</p>
        
<h2>15.编程实现memcopy</h2>

        <p>memcpy是一个用于内存拷贝的标准库函数。下面是一个手撕memcpy函数的简单实现：</p>
        <p>#include</p>
        <p>void myMemcpy(void* dest, const void* src, size_t size) { char* destPtr
          = static_cast&lt;char*&gt;(dest); const char* srcPtr = static_cast&lt;const
          char*&gt;(src);</p>
<pre><code>for (size_t i = 0; i &lt; size; ++i) {
    destPtr[i] = srcPtr[i];
}
</code></pre>

        <p>}</p>
        <p>int main() { int source[] = {1, 2, 3, 4, 5}; int destination[5];</p>
<pre><code>myMemcpy(destination, source, sizeof(source));

for (const auto&amp; element : destination) {
    std::cout &lt;&lt; element &lt;&lt; " ";
}

return 0;
</code></pre>

        <p>}</p>
        <p>在这个示例中，myMemcpy函数接受三个参数：目标指针 dest、源指针 src 和要拷贝的字节数 size。通过将指针转换为 char*
          类型，我们可以按字节进行拷贝。然后，使用一个循环来逐字节地将源数据复制到目标内存中。</p>
        <p>注意，在实际开发中，建议使用标准库提供的 memcpy 函数或其他相关的安全替代品，以确保更高的效率和正确性。上述手撕版本只是为了演示原理，并不考虑边界情况和优化处理。</p>
      </div>
    </div>
  </body>

</html>